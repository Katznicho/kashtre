name: Deploy Staging Branch to Hostinger (Root)

on:
  push:
    branches:
      - staging

jobs:
  deploy:
    name: Deploy Staging Branch
    runs-on: ubuntu-latest
    env:
      ACTIONS_RUNNER_DEBUG: true
      ACTIONS_STEP_DEBUG: true

    steps:
      # Step 1: Checkout the code
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up PHP
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: mbstring, xml, bcmath, ctype, json, tokenizer, curl
          coverage: none

      # Step 3: Install Composer dependencies
      - name: Install Composer dependencies
        run: composer install --no-dev --optimize-autoloader --no-interaction --ignore-platform-reqs

      # Step 4: Install sshpass
      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass || { echo "Failed to install sshpass"; exit 1; }
          sshpass -v || { echo "sshpass not found after installation"; exit 1; }

      # Step 5: Test SSH Connection
      - name: Test SSH Connection
        run: |
          echo "Testing SSH connection to ${{ secrets.FTP_SERVER }}:65002..."
          sshpass -p "${{ secrets.FTP_PASSWORD }}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=60 -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -p 65002 ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }} whoami || { echo "SSH connection failed"; exit 1; }
          echo "SSH connection successful, testing directory access..."
          sshpass -p "${{ secrets.FTP_PASSWORD }}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=60 -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -p 65002 ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }} "echo 'Test command execution' && ls -la /home/u242329769/domains/staging.kashtre.com/public_html" || { echo "Directory access failed"; exit 1; }

      # Step 6: Deploy to Hostinger via SSH
      - name: Deploy to Hostinger
        env:
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
        run: |
          # Define deployment directory
          DEPLOY_DIR="/home/u242329769/domains/staging.kashtre.com/public_html"

          # Debug: List local files in GITHUB_WORKSPACE
          echo "Local files in GITHUB_WORKSPACE:"
          ls -la $GITHUB_WORKSPACE

          # Copy files using rsync with sshpass, excluding unnecessary files, with --delete to remove old files
          echo "Starting file transfer with rsync..."
          sshpass -p "$FTP_PASSWORD" rsync -avz --delete \
            --exclude '.env' \
            --exclude '.htaccess' \
            --exclude 'node_modules/' \
            --exclude '.git/' \
            --exclude 'tests/' \
            --exclude '.DS_Store' \
            --exclude '*.log' \
            --exclude 'storage/logs/' \
            --exclude 'storage/framework/cache/' \
            --exclude 'storage/framework/sessions/' \
            --exclude 'storage/framework/views/' \
            --timeout=600 \
            --progress \
            -e "ssh -p 65002 -o StrictHostKeyChecking=no -o ConnectTimeout=60 -o ServerAliveInterval=30 -o ServerAliveCountMax=3" \
            $GITHUB_WORKSPACE/ ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }}:"$DEPLOY_DIR" || { echo "rsync failed"; exit 1; }
          
          echo "File transfer completed successfully"

          # Run SSH commands to verify and configure
          echo "Running post-deployment configuration..."
          sshpass -p "$FTP_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=60 -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -p 65002 ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }} bash -c '
            DEPLOY_DIR="/home/u242329769/domains/staging.kashtre.com/public_html"
            cd "$DEPLOY_DIR" || { echo "Failed to change directory to $DEPLOY_DIR"; exit 1; }

            # Debug: List directory contents after rsync
            echo "Directory contents after rsync:"
            ls -la

            # Debug: Check public/build directory
            echo "Contents of public/build:"
            ls -la public/build || echo "public/build directory not found (manually uploaded)"

            # Debug: Check .env contents (sanitized)
            if [ -f ".env" ]; then
              echo ".env exists"
              grep -v "DB_" .env || echo "Failed to read .env"
            else
              echo "Error: .env file not found"
              exit 1
            fi

            # Debug: Check vendor directory
            if [ -d "vendor" ]; then
              echo "vendor directory exists"
              ls -la vendor/ | head -10
            else
              echo "Error: vendor directory not found"
              exit 1
            fi

            # Debug: Check composer autoload files
            if [ -f "vendor/autoload.php" ]; then
              echo "vendor/autoload.php exists"
            else
              echo "Error: vendor/autoload.php not found"
              exit 1
            fi

            # Set permissions for storage and cache directories
            if [ -d "storage" ] && [ -d "bootstrap/cache" ]; then
              chmod -R 755 storage bootstrap/cache
              chown -R u242329769:u242329769 storage bootstrap/cache
            else
              echo "Warning: storage or bootstrap/cache directory not found"
            fi

            # Verify PHP is available
            if command -v php >/dev/null 2>&1; then
              echo "PHP found: $(php -v)"
            else
              echo "Error: PHP not found on server"
              exit 1
            fi

            # Verify artisan exists before running commands
            if [ -f "artisan" ]; then
              # Debug: List available migrations
              echo "Listing migrations:"
              ls -la database/migrations

              # Debug: Check migrations table
              php artisan migrate:status || echo "Failed to check migration status"

              # Ensure migrations table exists
              php artisan migrate:install || echo "Failed to create migrations table"

              # Remove conflicting migration files that should not exist
              echo "Removing conflicting migration files..."
              rm -f database/migrations/2025_07_01_000000_create_users_table.php || echo "Migration file not found (good)"
              rm -f database/migrations/2025_07_02_000000_add_two_factor_columns_to_users_table.php || echo "Migration file not found (good)"

              # Create temporary directory for PsySH if needed
              mkdir -p /tmp/psysh-runtime || echo "PsySH runtime dir creation skipped"
              export XDG_RUNTIME_DIR=/tmp/psysh-runtime

              # Mark existing migrations as run to prevent conflicts
              echo "Marking existing migrations as already run..."
              
              # Check if users table exists and mark the migration as run
              USERS_EXISTS=$(php -r "
                require 'vendor/autoload.php';
                \$app = require_once 'bootstrap/app.php';
                \$kernel = \$app->make(Illuminate\Contracts\Console\Kernel::class);
                \$kernel->bootstrap();
                try {
                  \$exists = Schema::hasTable('users');
                  echo \$exists ? '1' : '0';
                } catch (Exception \$e) {
                  echo '0';
                }
              " 2>/dev/null)
              
              if [ "$USERS_EXISTS" = "1" ]; then
                echo "Users table exists, marking 2014_10_12_000000_create_users_table as run"
                php artisan migrate:status | grep "2014_10_12_000000_create_users_table" || php -r "
                  require 'vendor/autoload.php';
                  \$app = require_once 'bootstrap/app.php';
                  \$kernel = \$app->make(Illuminate\Contracts\Console\Kernel::class);
                  \$kernel->bootstrap();
                  try {
                    DB::table('migrations')->insert([
                      'migration' => '2014_10_12_000000_create_users_table',
                      'batch' => 1
                    ]);
                    echo 'Migration marked as run successfully';
                  } catch (Exception \$e) {
                    echo 'Migration already marked as run or failed: ' . \$e->getMessage();
                  }
                "
              fi
              
              # Alternative approach using direct mysql if tinker fails
              echo "Using alternative migration marking approach..."

              # Run migrations with verbose output and handle conflicts
              echo "Running migrations..."
              php artisan migrate --force --verbose || {
                echo "Migration failed, attempting to resolve conflicts..."
                # Try to mark any remaining conflicting migrations as run
                php -r "
                  require 'vendor/autoload.php';
                  \$app = require_once 'bootstrap/app.php';
                  \$kernel = \$app->make(Illuminate\Contracts\Console\Kernel::class);
                  \$kernel->bootstrap();
                  try {
                    \$pendingMigrations = DB::table('migrations')->pluck('migration')->toArray();
                    \$files = glob('database/migrations/*.php');
                    foreach (\$files as \$file) {
                      \$migrationName = basename(\$file, '.php');
                      if (!in_array(\$migrationName, \$pendingMigrations)) {
                        try {
                          DB::table('migrations')->insert([
                            'migration' => \$migrationName,
                            'batch' => 1
                          ]);
                          echo 'Marked ' . \$migrationName . ' as run' . PHP_EOL;
                        } catch (Exception \$e) {
                          echo 'Failed to mark ' . \$migrationName . ': ' . \$e->getMessage() . PHP_EOL;
                        }
                      }
                    }
                  } catch (Exception \$e) {
                    echo 'Error resolving migrations: ' . \$e->getMessage() . PHP_EOL;
                  }
                "
                echo "Migration conflict resolution completed"
              }

              # Check if seeding is needed (check for specific business email to avoid conflicts)
              BUSINESS_EXISTS=$(php -r "
                require 'vendor/autoload.php';
                \$app = require_once 'bootstrap/app.php';
                \$kernel = \$app->make(Illuminate\Contracts\Console\Kernel::class);
                \$kernel->bootstrap();
                try {
                  \$exists = DB::table('businesses')->where('email', 'katznicho@gmail.com')->exists();
                  echo \$exists ? '1' : '0';
                } catch (Exception \$e) {
                  echo '0';
                }
              " 2>/dev/null)
              
              if [ "$BUSINESS_EXISTS" = "1" ]; then
                echo "Core business data already exists, skipping seeding to avoid conflicts"
              else
                echo "No core business data found, running seeders"
                php artisan db:seed --force --verbose || echo "Seeding failed but continuing deployment"
              fi

              # Create storage link
              php artisan storage:link || echo "Storage link already exists or failed to create"

                        # Install/update Composer dependencies
          echo "Installing Composer dependencies..."
          composer install --no-dev --optimize-autoloader --no-interaction --ignore-platform-reqs || echo "Composer install failed"
          
          # Clear and rebuild autoloader
          echo "Rebuilding Composer autoloader..."
          composer dump-autoload --optimize || echo "Composer autoload rebuild failed"

          # Clear all caches first
          echo "Clearing application caches..."
          php artisan optimize:clear || echo "Optimize clear failed"
          php artisan config:clear || echo "Config clear failed"
          php artisan cache:clear || echo "Cache clear failed"
          php artisan route:clear || echo "Route clear failed"
          php artisan view:clear || echo "View clear failed"
          php artisan bootstrap:clear || echo "Bootstrap clear failed"
          
          # Clear Livewire cache and rediscover components
          echo "Setting up Livewire components..."
          php artisan livewire:clear-cache || echo "Livewire cache clear failed"
          php artisan livewire:discover || echo "Livewire discover failed"
          
          # Rebuild caches
          echo "Rebuilding application caches..."
          php artisan config:cache || echo "Config cache failed"
          php artisan route:cache || echo "Route cache failed"
          php artisan view:cache || echo "View cache failed"
          
          # Verify Livewire components are discovered
          echo "Verifying Livewire components..."
          php artisan livewire:list || echo "Livewire list failed"
          
          # Final optimization
          echo "Running final optimization..."
          php artisan optimize || echo "Final optimize failed"

              # Restart queue workers if applicable
              php artisan queue:restart || echo "Queue restart not available"
            else
              echo "Error: artisan file not found"
              exit 1
            fi
          ' 